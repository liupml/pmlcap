/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Support for splitting captures into multiple files with a maximum
 * file size:
 *
 * Copyright (c) 2001
 *	Seth Webster <swebster@sst.ll.mit.edu>
 */

#ifndef lint
static const char copyright[] _U_ =
    "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n\
The Regents of the University of California.  All rights reserved.\n";
#endif

/*
 * tcpdump - dump traffic on a network
 *
 * First written in 1987 by Van Jacobson, Lawrence Berkeley Laboratory.
 * Mercilessly hacked and occasionally improved since then via the
 * combined efforts of Van, Steve McCanne and Craig Leres of LBL.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

/*
 * Mac OS X may ship pcap.h from libpcap 0.6 with a libpcap based on
 * 0.8.  That means it has pcap_findalldevs() but the header doesn't
 * define pcap_if_t, meaning that we can't actually *use* pcap_findalldevs().
 */
#ifdef HAVE_PCAP_FINDALLDEVS
#ifndef HAVE_PCAP_IF_T
#undef HAVE_PCAP_FINDALLDEVS
#endif
#endif

#include <sys/types.h>
#include <pthread.h>
#include <assert.h>

#include <netdissect-stdinc.h>

#include <sys/stat.h>

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#ifdef HAVE_LIBCRYPTO
#include <openssl/crypto.h>
#endif

#ifdef HAVE_GETOPT_LONG
#include <getopt.h>
#else
#include "getopt_long.h"
#endif
/* Capsicum-specific code requires macros from <net/bpf.h>, which will fail
 * to compile if <pcap.h> has already been included; including the headers
 * in the opposite order works fine.
 */
#ifdef HAVE_CAPSICUM
#include <sys/capability.h>
#include <sys/ioccom.h>
#include <net/bpf.h>
#include <libgen.h>
#endif	/* HAVE_CAPSICUM */
#include <pcap.h>
#include <signal.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#ifndef _WIN32
#include <sys/wait.h>
#include <sys/resource.h>
#include <pwd.h>
#include <grp.h>
#endif /* _WIN32 */

/* capabilities convenience library */
/* If a code depends on HAVE_LIBCAP_NG, it depends also on HAVE_CAP_NG_H.
 * If HAVE_CAP_NG_H is not defined, undefine HAVE_LIBCAP_NG.
 * Thus, the later tests are done only on HAVE_LIBCAP_NG.
 */
#ifdef HAVE_LIBCAP_NG
#ifdef HAVE_CAP_NG_H
#include <cap-ng.h>
#else
#undef HAVE_LIBCAP_NG
#endif /* HAVE_CAP_NG_H */
#endif /* HAVE_LIBCAP_NG */

#include "netdissect.h"
#include "interface.h"
#include "addrtoname.h"
#include "machdep.h"
#include "setsignal.h"
#include "gmt2local.h"
#include "pcap-missing.h"
#include "ascii_strcasecmp.h"
#include "print.h"
//---------------------
#include <unistd.h>
#include <pthread.h>

//#define DUMP_DEBUG 1
//#define CZL  1

volatile unsigned int jupackets_captured = 0;
volatile unsigned char	run  = 1;
volatile unsigned char ENDWRITE2FILE = 0;
char 	file_name[32] = {0};
char * current_name = file_name;
volatile long int g_writedlen = 0;
int flagforprint = 0;
int flagforfilename = 0;

#define barrier() __asm__ __volatile__("":::"memory")
#define MAX_PACKETSNUM_IN_FILE 1000000
#define MAX_PACKET_LEN  (500 *1024*1024)
#define MIN_SAFE_LEN  (400*1024)
#define MAX_WAIE_SECOND  10
//#define MIN_DU_FILE  (15*1024*1024)
#define MAX_DU_FILE  (20*1*1) //G:20G
#define MAX_DEL_FILE  (500*1024*1024) //B:500M

#define MAX_DUMP_FILE_SIZE (100*1024*1024)


pthread_mutex_t mut1; //互斥锁类?


struct pcap_header{
	unsigned int	magic;		//固定?0xa1b2c3d4
	unsigned short	ver_major;	//主版本号
	unsigned short	ver_minor;	//次版本号
	unsigned int	time_zone;	//当地标准时间，未使用，为0?
	unsigned int	time_stamp;	//时间戳的精度，未使用，为0?
	unsigned int	snaplen;	//抓获数据包的?大长度，抓取?有包就设置全F，否则就设置为具体想抓取的最大的值??
	unsigned int	linktype;	//以太网类型还是PPP类型还是802.11…?常用的是以太网类型?
};

typedef struct{
	bpf_int32 tv_sec;		/* seconds */
    bpf_int32 tv_usec;		/* microseconds */
    bpf_u_int32 caplen;		/* length of portion present */
    bpf_u_int32 len;		/* length this packet (off wire) */
}stpcap_time;

typedef struct {
	unsigned int wpos;
	unsigned int wloop;
	unsigned int rpos;
	unsigned int rloop;
	unsigned int captime;
	unsigned int w2ftime;	
	unsigned int endpos;
	unsigned char *buffer;  //[MAX_PACKET_LEN+1];
}stMybuffer;

stMybuffer stbuf, *pstbuf;
#define PFUNLINE  fprintf(stdout,"\t%s,line=%d\n",__FUNCTION__,__LINE__)

void *pstmyfile;


//#define MYFILERMODE "ether[12:2] & 0xffff != 0x0800 || (ether[22:2] & 0xffff = 0x0521 && ether[24:2] & 0xffff = 0x2715)"
#ifdef CZL
#define MYFILERMODE "udp && src 192.168.0.2 && dst 172.171.17.202"
#else
#define MYFILERMODE "udp && src 192.168.1.100"
#endif

//&& src 192.168.75.130
#ifndef PATH_MAX
#define PATH_MAX 1024
#endif

#ifdef SIGINFO
#define SIGNAL_REQ_INFO SIGINFO
#elif SIGUSR1
#define SIGNAL_REQ_INFO SIGUSR1
#endif

static int Bflag;			/* buffer size */
static long Cflag;			/* rotate dump files after this many bytes */
static int Cflag_count;			/* Keep track of which file number we're writing */
static int Dflag;			/* list available devices and exit */
/*
 * This is exported because, in some versions of libpcap, if libpcap
 * is built with optimizer debugging code (which is *NOT* the default
 * configuration!), the library *imports*(!) a variable named dflag,
 * under the expectation that tcpdump is exporting it, to govern
 * how much debugging information to print when optimizing
 * the generated BPF code.
 *
 * This is a horrible hack; newer versions of libpcap don't import
 * dflag but, instead, *if* built with optimizer debugging code,
 * *export* a routine to set that flag.
 */
int dflag;				/* print filter code */
static int Gflag;			/* rotate dump files after this many seconds */
static int Gflag_count;			/* number of files created with Gflag rotation */
static time_t Gflag_time;		/* The last time_t the dump file was rotated. */
static int Lflag;			/* list available data link types and exit */
static int Iflag;			/* rfmon (monitor) mode */
#ifdef HAVE_PCAP_SET_TSTAMP_TYPE
static int Jflag;			/* list available time stamp types */
#endif
static int jflag = -1;			/* packet time stamp source */
static int pflag;			/* don't go promiscuous */
#ifdef HAVE_PCAP_SETDIRECTION
static int Qflag = -1;			/* restrict captured packet by send/receive direction */
#endif
static int Uflag;			/* "unbuffered" output of dump files */
static int Wflag;			/* recycle output files after this number of files */
static int WflagChars;
static char *zflag = NULL;		/* compress each savefile using a specified command (like gzip or bzip2) */
static int immediate_mode;

static int infodelay;
static int infoprint;

char *program_name;

int gettimeofdayms(void);
void judgeifbig(void);



/* Forwards */
static void error(FORMAT_STRING(const char *), ...) NORETURN PRINTFLIKE(1, 2);
static void warning(FORMAT_STRING(const char *), ...) PRINTFLIKE(1, 2);
static void exit_tcpdump(int) NORETURN;
static RETSIGTYPE cleanup(int);
static RETSIGTYPE child_cleanup(int);
static void print_version(void);
static void print_usage(void);
static void show_tstamp_types_and_exit(pcap_t *, const char *device) NORETURN;
static void show_dlts_and_exit(pcap_t *, const char *device) NORETURN;
#ifdef HAVE_PCAP_FINDALLDEVS
static void show_devices_and_exit (void) NORETURN;
#endif

static void print_packet(u_char *, const struct pcap_pkthdr *, const u_char *);
static void dump_packet_and_trunc(u_char *, const struct pcap_pkthdr *, const u_char *);
static void dump_packet(u_char *, const struct pcap_pkthdr *, const u_char *);
static void droproot(const char *, const char *);

#ifdef SIGNAL_REQ_INFO
RETSIGTYPE requestinfo(int);
#endif

#if defined(USE_WIN32_MM_TIMER)
  #include <MMsystem.h>
  static UINT timer_id;
  static void CALLBACK verbose_stats_dump(UINT, UINT, DWORD_PTR, DWORD_PTR, DWORD_PTR);
#elif defined(HAVE_ALARM)
  static void verbose_stats_dump(int sig);
#endif

static void info(int);
static u_int packets_captured;

#ifdef HAVE_PCAP_FINDALLDEVS
static const struct tok status_flags[] = {
#ifdef PCAP_IF_UP
	{ PCAP_IF_UP,       "Up"       },
#endif
#ifdef PCAP_IF_RUNNING
	{ PCAP_IF_RUNNING,  "Running"  },
#endif
	{ PCAP_IF_LOOPBACK, "Loopback" },
	{ 0, NULL }
};
#endif

static pcap_t *pd;

static int supports_monitor_mode;

extern int optind;
extern int opterr;
extern char *optarg;

struct dump_info {
	char	*WFileName;
	char	*CurrentFileName;
	pcap_t	*pd;
	pcap_dumper_t *p;
#ifdef HAVE_CAPSICUM
	int	dirfd;
#endif
};

#if defined(HAVE_PCAP_SET_PARSER_DEBUG)
/*
 * We have pcap_set_parser_debug() in libpcap; declare it (it's not declared
 * by any libpcap header, because it's a special hack, only available if
 * libpcap was configured to include it, and only intended for use by
 * libpcap developers trying to debug the parser for filter expressions).
 */
#ifdef _WIN32
__declspec(dllimport)
#else /* _WIN32 */
extern
#endif /* _WIN32 */
void pcap_set_parser_debug(int);
#elif defined(HAVE_PCAP_DEBUG) || defined(HAVE_YYDEBUG)
/*
 * We don't have pcap_set_parser_debug() in libpcap, but we do have
 * pcap_debug or yydebug.  Make a local version of pcap_set_parser_debug()
 * to set the flag, and define HAVE_PCAP_SET_PARSER_DEBUG.
 */
static void
pcap_set_parser_debug(int value)
{
#ifdef HAVE_PCAP_DEBUG
	extern int pcap_debug;

	pcap_debug = value;
#else /* HAVE_PCAP_DEBUG */
	extern int yydebug;

	yydebug = value;
#endif /* HAVE_PCAP_DEBUG */
}

#define HAVE_PCAP_SET_PARSER_DEBUG
#endif

#if defined(HAVE_PCAP_SET_OPTIMIZER_DEBUG)
/*
 * We have pcap_set_optimizer_debug() in libpcap; declare it (it's not declared
 * by any libpcap header, because it's a special hack, only available if
 * libpcap was configured to include it, and only intended for use by
 * libpcap developers trying to debug the optimizer for filter expressions).
 */
#ifdef _WIN32
__declspec(dllimport)
#else /* _WIN32 */
extern
#endif /* _WIN32 */
void pcap_set_optimizer_debug(int);
#endif

/* VARARGS */
static void
error(const char *fmt, ...)
{
	va_list ap;

	(void)fprintf(stderr, "%s: ", program_name);
	va_start(ap, fmt);
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	if (*fmt) {
		fmt += strlen(fmt);
		if (fmt[-1] != '\n')
			(void)fputc('\n', stderr);
	}
	exit_tcpdump(1);
	/* NOTREACHED */
}

/* VARARGS */
static void
warning(const char *fmt, ...)
{
	va_list ap;

	(void)fprintf(stderr, "%s: WARNING: ", program_name);
	va_start(ap, fmt);
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	if (*fmt) {
		fmt += strlen(fmt);
		if (fmt[-1] != '\n')
			(void)fputc('\n', stderr);
	}
}

static void
exit_tcpdump(int status)
{
	nd_cleanup();
	exit(status);
}

#ifdef HAVE_PCAP_SET_TSTAMP_TYPE
static void
show_tstamp_types_and_exit(pcap_t *pc, const char *device)
{
	int n_tstamp_types;
	int *tstamp_types = 0;
	const char *tstamp_type_name;
	int i;

	n_tstamp_types = pcap_list_tstamp_types(pc, &tstamp_types);
	if (n_tstamp_types < 0)
		error("%s", pcap_geterr(pc));

	if (n_tstamp_types == 0) {
		fprintf(stderr, "Time stamp type cannot be set for %s\n",
		    device);
		exit_tcpdump(0);
	}
	fprintf(stderr, "Time stamp types for %s (use option -j to set):\n",
	    device);
	for (i = 0; i < n_tstamp_types; i++) {
		tstamp_type_name = pcap_tstamp_type_val_to_name(tstamp_types[i]);
		if (tstamp_type_name != NULL) {
			(void) fprintf(stderr, "  %s (%s)\n", tstamp_type_name,
			    pcap_tstamp_type_val_to_description(tstamp_types[i]));
		} else {
			(void) fprintf(stderr, "  %d\n", tstamp_types[i]);
		}
	}
	pcap_free_tstamp_types(tstamp_types);
	exit_tcpdump(0);
}
#endif

static void
show_dlts_and_exit(pcap_t *pc, const char *device)
{
	int n_dlts, i;
	int *dlts = 0;
	const char *dlt_name;

	n_dlts = pcap_list_datalinks(pc, &dlts);
	if (n_dlts < 0)
		error("%s", pcap_geterr(pc));
	else if (n_dlts == 0 || !dlts)
		error("No data link types.");

	/*
	 * If the interface is known to support monitor mode, indicate
	 * whether these are the data link types available when not in
	 * monitor mode, if -I wasn't specified, or when in monitor mode,
	 * when -I was specified (the link-layer types available in
	 * monitor mode might be different from the ones available when
	 * not in monitor mode).
	 */
	if (supports_monitor_mode)
		(void) fprintf(stderr, "Data link types for %s %s (use option -y to set):\n",
		    device,
		    Iflag ? "when in monitor mode" : "when not in monitor mode");
	else
		(void) fprintf(stderr, "Data link types for %s (use option -y to set):\n",
		    device);

	for (i = 0; i < n_dlts; i++) {
		dlt_name = pcap_datalink_val_to_name(dlts[i]);
		if (dlt_name != NULL) {
			(void) fprintf(stderr, "  %s (%s)", dlt_name,
			    pcap_datalink_val_to_description(dlts[i]));

			/*
			 * OK, does tcpdump handle that type?
			 */
			if (!has_printer(dlts[i]))
				(void) fprintf(stderr, " (printing not supported)");
			fprintf(stderr, "\n");
		} else {
			(void) fprintf(stderr, "  DLT %d (printing not supported)\n",
			    dlts[i]);
		}
	}
#ifdef HAVE_PCAP_FREE_DATALINKS
	pcap_free_datalinks(dlts);
#endif
	exit_tcpdump(0);
}

#ifdef HAVE_PCAP_FINDALLDEVS
static void
show_devices_and_exit (void)
{
	pcap_if_t *dev, *devlist;
	char ebuf[PCAP_ERRBUF_SIZE];
	int i;

	if (pcap_findalldevs(&devlist, ebuf) < 0)
		error("%s", ebuf);
	for (i = 0, dev = devlist; dev != NULL; i++, dev = dev->next) {
		printf("%d.%s", i+1, dev->name);
		if (dev->description != NULL)
			printf(" (%s)", dev->description);
		if (dev->flags != 0)
			printf(" [%s]", bittok2str(status_flags, "none", dev->flags));
		printf("\n");
	}
	pcap_freealldevs(devlist);
	exit_tcpdump(0);
}
#endif /* HAVE_PCAP_FINDALLDEVS */

/*
 * Short options.
 *
 * Note that there we use all letters for short options except for g, k,
 * o, and P, and those are used by other versions of tcpdump, and we should
 * only use them for the same purposes that the other versions of tcpdump
 * use them:
 *
 * OS X tcpdump uses -g to force non--v output for IP to be on one
 * line, making it more "g"repable;
 *
 * OS X tcpdump uses -k to specify that packet comments in pcap-ng files
 * should be printed;
 *
 * OpenBSD tcpdump uses -o to indicate that OS fingerprinting should be done
 * for hosts sending TCP SYN packets;
 *
 * OS X tcpdump uses -P to indicate that -w should write pcap-ng rather
 * than pcap files.
 *
 * OS X tcpdump also uses -Q to specify expressions that match packet
 * metadata, including but not limited to the packet direction.
 * The expression syntax is different from a simple "in|out|inout",
 * and those expressions aren't accepted by OS X tcpdump, but the
 * equivalents would be "in" = "dir=in", "out" = "dir=out", and
 * "inout" = "dir=in or dir=out", and the parser could conceivably
 * special-case "in", "out", and "inout" as expressions for backwards
 * compatibility, so all is not (yet) lost.
 */

/*
 * Set up flags that might or might not be supported depending on the
 * version of libpcap we're using.
 */
#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)
#define B_FLAG		"B:"
#define B_FLAG_USAGE	" [ -B size ]"
#else /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */
#define B_FLAG
#define B_FLAG_USAGE
#endif /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */

#ifdef HAVE_PCAP_CREATE
#define I_FLAG		"I"
#else /* HAVE_PCAP_CREATE */
#define I_FLAG
#endif /* HAVE_PCAP_CREATE */

#ifdef HAVE_PCAP_SET_TSTAMP_TYPE
#define j_FLAG		"j:"
#define j_FLAG_USAGE	" [ -j tstamptype ]"
#define J_FLAG		"J"
#else /* PCAP_ERROR_TSTAMP_TYPE_NOTSUP */
#define j_FLAG
#define j_FLAG_USAGE
#define J_FLAG
#endif /* PCAP_ERROR_TSTAMP_TYPE_NOTSUP */

#ifdef HAVE_PCAP_FINDALLDEVS
#define D_FLAG	"D"
#else
#define D_FLAG
#endif

#ifdef HAVE_PCAP_DUMP_FLUSH
#define U_FLAG	"U"
#else
#define U_FLAG
#endif

#ifdef HAVE_PCAP_SETDIRECTION
#define Q_FLAG "Q:"
#else
#define Q_FLAG
#endif

#define SHORTOPTS "aAb" B_FLAG "c:C:d" D_FLAG "eE:fF:G:hHi:" I_FLAG j_FLAG J_FLAG "KlLm:M:nNOpq" Q_FLAG "r:s:StT:u" U_FLAG "vV:w:W:xXy:Yz:Z:#"

/*
 * Long options.
 *
 * We do not currently have long options corresponding to all short
 * options; we should probably pick appropriate option names for them.
 *
 * However, the short options where the number of times the option is
 * specified matters, such as -v and -d and -t, should probably not
 * just map to a long option, as saying
 *
 *  tcpdump --verbose --verbose
 *
 * doesn't make sense; it should be --verbosity={N} or something such
 * as that.
 *
 * For long options with no corresponding short options, we define values
 * outside the range of ASCII graphic characters, make that the last
 * component of the entry for the long option, and have a case for that
 * option in the switch statement.
 */
#define OPTION_VERSION		128
#define OPTION_TSTAMP_PRECISION	129
#define OPTION_IMMEDIATE_MODE	130

static const struct option longopts[] = {
#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)
	{ "buffer-size", required_argument, NULL, 'B' },
#endif
	{ "list-interfaces", no_argument, NULL, 'D' },
	{ "help", no_argument, NULL, 'h' },
	{ "interface", required_argument, NULL, 'i' },
#ifdef HAVE_PCAP_CREATE
	{ "monitor-mode", no_argument, NULL, 'I' },
#endif
#ifdef HAVE_PCAP_SET_TSTAMP_TYPE
	{ "time-stamp-type", required_argument, NULL, 'j' },
	{ "list-time-stamp-types", no_argument, NULL, 'J' },
#endif
#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	{ "time-stamp-precision", required_argument, NULL, OPTION_TSTAMP_PRECISION},
#endif
	{ "dont-verify-checksums", no_argument, NULL, 'K' },
	{ "list-data-link-types", no_argument, NULL, 'L' },
	{ "no-optimize", no_argument, NULL, 'O' },
	{ "no-promiscuous-mode", no_argument, NULL, 'p' },
#ifdef HAVE_PCAP_SETDIRECTION
	{ "direction", required_argument, NULL, 'Q' },
#endif
	{ "snapshot-length", required_argument, NULL, 's' },
	{ "absolute-tcp-sequence-numbers", no_argument, NULL, 'S' },
#ifdef HAVE_PCAP_DUMP_FLUSH
	{ "packet-buffered", no_argument, NULL, 'U' },
#endif
	{ "linktype", required_argument, NULL, 'y' },
#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE
	{ "immediate-mode", no_argument, NULL, OPTION_IMMEDIATE_MODE },
#endif
#ifdef HAVE_PCAP_SET_PARSER_DEBUG
	{ "debug-filter-parser", no_argument, NULL, 'Y' },
#endif
	{ "relinquish-privileges", required_argument, NULL, 'Z' },
	{ "number", no_argument, NULL, '#' },
	{ "version", no_argument, NULL, OPTION_VERSION },
	{ NULL, 0, NULL, 0 }
};

#ifndef _WIN32
/* Drop root privileges and chroot if necessary */
static void
droproot(const char *username, const char *chroot_dir)
{
	struct passwd *pw = NULL;

	if (chroot_dir && !username) {
		fprintf(stderr, "%s: Chroot without dropping root is insecure\n",
			program_name);
		exit_tcpdump(1);
	}

	pw = getpwnam(username);
	if (pw) {
		if (chroot_dir) {
			if (chroot(chroot_dir) != 0 || chdir ("/") != 0) {
				fprintf(stderr, "%s: Couldn't chroot/chdir to '%.64s': %s\n",
					program_name, chroot_dir, pcap_strerror(errno));
				exit_tcpdump(1);
			}
		}
#ifdef HAVE_LIBCAP_NG
		{
			int ret = capng_change_id(pw->pw_uid, pw->pw_gid, CAPNG_NO_FLAG);
			if (ret < 0)
				error("capng_change_id(): return %d\n", ret);
			else
				fprintf(stderr, "dropped privs to %s\n", username);
		}
#else
		if (initgroups(pw->pw_name, pw->pw_gid) != 0 ||
		    setgid(pw->pw_gid) != 0 || setuid(pw->pw_uid) != 0) {
			fprintf(stderr, "%s: Couldn't change to '%.32s' uid=%lu gid=%lu: %s\n",
				program_name, username,
				(unsigned long)pw->pw_uid,
				(unsigned long)pw->pw_gid,
				pcap_strerror(errno));
			exit_tcpdump(1);
		}
		else {
			fprintf(stderr, "dropped privs to %s\n", username);
		}
#endif /* HAVE_LIBCAP_NG */
	}
	else {
		fprintf(stderr, "%s: Couldn't find user '%.32s'\n",
			program_name, username);
		exit_tcpdump(1);
	}
#ifdef HAVE_LIBCAP_NG
	/* We don't need CAP_SETUID, CAP_SETGID and CAP_SYS_CHROOT any more. */
	capng_updatev(
		CAPNG_DROP,
		CAPNG_EFFECTIVE | CAPNG_PERMITTED,
		CAP_SETUID,
		CAP_SETGID,
		CAP_SYS_CHROOT,
		-1);
	capng_apply(CAPNG_SELECT_BOTH);
#endif /* HAVE_LIBCAP_NG */

}
#endif /* _WIN32 */

static int
getWflagChars(int x)
{
	int c = 0;

	x -= 1;
	while (x > 0) {
		c += 1;
		x /= 10;
	}

	return c;
}


static void
MakeFilename(char *buffer, char *orig_name, int cnt, int max_chars)
{
        char *filename = malloc(PATH_MAX + 1);
        if (filename == NULL)
            error("Makefilename: malloc");

        /* Process with strftime if Gflag is set. */
        if (Gflag != 0) {
          struct tm *local_tm;

          /* Convert Gflag_time to a usable format */
          if ((local_tm = localtime(&Gflag_time)) == NULL) {
                  error("MakeTimedFilename: localtime");
          }

          /* There's no good way to detect an error in strftime since a return
           * value of 0 isn't necessarily failure.
           */
          strftime(filename, PATH_MAX, orig_name, local_tm);
        } else {
          strncpy(filename, orig_name, PATH_MAX);
        }

	if (cnt == 0 && max_chars == 0)
		strncpy(buffer, filename, PATH_MAX + 1);
	else
		if (snprintf(buffer, PATH_MAX + 1, "%s%0*d", filename, max_chars, cnt) > PATH_MAX)
                  /* Report an error if the filename is too large */
                  error("too many output files or filename is too long (> %d)", PATH_MAX);
        free(filename);
}

static char *
get_next_file(FILE *VFile, char *ptr)
{
	char *ret;
	size_t len;

	ret = fgets(ptr, PATH_MAX, VFile);
	if (!ret)
		return NULL;

	len = strlen (ptr);
	if (len > 0 && ptr[len - 1] == '\n')
		ptr[len - 1] = '\0';

	return ret;
}

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
static int
tstamp_precision_from_string(const char *precision)
{
	if (strncmp(precision, "nano", strlen("nano")) == 0)
		return PCAP_TSTAMP_PRECISION_NANO;

	if (strncmp(precision, "micro", strlen("micro")) == 0)
		return PCAP_TSTAMP_PRECISION_MICRO;

	return -EINVAL;
}

static const char *
tstamp_precision_to_string(int precision)
{
	switch (precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		return "micro";

	case PCAP_TSTAMP_PRECISION_NANO:
		return "nano";

	default:
		return "unknown";
	}
}
#endif

#ifdef HAVE_CAPSICUM
/*
 * Ensure that, on a dump file's descriptor, we have all the rights
 * necessary to make the standard I/O library work with an fdopen()ed
 * FILE * from that descriptor.
 *
 * A long time ago, in a galaxy far far away, AT&T decided that, instead
 * of providing separate APIs for getting and setting the FD_ flags on a
 * descriptor, getting and setting the O_ flags on a descriptor, and
 * locking files, they'd throw them all into a kitchen-sink fcntl() call
 * along the lines of ioctl(), the fact that ioctl() operations are
 * largely specific to particular character devices but fcntl() operations
 * are either generic to all descriptors or generic to all descriptors for
 * regular files nonwithstanding.
 *
 * The Capsicum people decided that fine-grained control of descriptor
 * operations was required, so that you need to grant permission for
 * reading, writing, seeking, and fcntl-ing.  The latter, courtesy of
 * AT&T's decision, means that "fcntl-ing" isn't a thing, but a motley
 * collection of things, so there are *individual* fcntls for which
 * permission needs to be granted.
 *
 * The FreeBSD standard I/O people implemented some optimizations that
 * requires that the standard I/O routines be able to determine whether
 * the descriptor for the FILE * is open append-only or not; as that
 * descriptor could have come from an open() rather than an fopen(),
 * that requires that it be able to do an F_GETFL fcntl() to read
 * the O_ flags.
 *
 * Tcpdump uses ftell() to determine how much data has been written
 * to a file in order to, when used with -C, determine when it's time
 * to rotate capture files.  ftell() therefore needs to do an lseek()
 * to find out the file offset and must, thanks to the aforementioned
 * optimization, also know whether the descriptor is open append-only
 * or not.
 *
 * The net result of all the above is that we need to grant CAP_SEEK,
 * CAP_WRITE, and CAP_FCNTL with the CAP_FCNTL_GETFL subcapability.
 *
 * Perhaps this is the universe's way of saying that either
 *
 *	1) there needs to be an fopenat() call and a pcap_dump_openat() call
 *	   using it, so that Capsicum-capable tcpdump wouldn't need to do
 *	   an fdopen()
 *
 * or
 *
 *	2) there needs to be a cap_fdopen() call in the FreeBSD standard
 *	   I/O library that knows what rights are needed by the standard
 *	   I/O library, based on the open mode, and assigns them, perhaps
 *	   with an additional argument indicating, for example, whether
 *	   seeking should be allowed, so that tcpdump doesn't need to know
 *	   what the standard I/O library happens to require this week.
 */
static void
set_dumper_capsicum_rights(pcap_dumper_t *p)
{
	int fd = fileno(pcap_dump_file(p));
	cap_rights_t rights;

	cap_rights_init(&rights, CAP_SEEK, CAP_WRITE, CAP_FCNTL);
	if (cap_rights_limit(fd, &rights) < 0 && errno != ENOSYS) {
		error("unable to limit dump descriptor");
	}
	if (cap_fcntls_limit(fd, CAP_FCNTL_GETFL) < 0 && errno != ENOSYS) {
		error("unable to limit dump descriptor fcntls");
	}
}
#endif

/*
 * Copy arg vector into a new buffer, concatenating arguments with spaces.
 */
static char *
copy_argv(register char **argv)
{
	register char **p;
	register u_int len = 0;
	char *buf;
	char *src, *dst;

	p = argv;
	if (*p == NULL)
		return 0;

	while (*p)
		len += strlen(*p++) + 1;

	buf = (char *)malloc(len);
	if (buf == NULL)
		error("copy_argv: malloc");

	p = argv;
	dst = buf;
	while ((src = *p++) != NULL) {
		while ((*dst++ = *src++) != '\0')
			;
		dst[-1] = ' ';
	}
	dst[-1] = '\0';

	return buf;
}

/*
 * On Windows, we need to open the file in binary mode, so that
 * we get all the bytes specified by the size we get from "fstat()".
 * On UNIX, that's not necessary.  O_BINARY is defined on Windows;
 * we define it as 0 if it's not defined, so it does nothing.
 */
#ifndef O_BINARY
#define O_BINARY	0
#endif

static char *
read_infile(char *fname)
{
	register int i, fd, cc;
	register char *cp;
	struct stat buf;

	fd = open(fname, O_RDONLY|O_BINARY);
	if (fd < 0)
		error("can't open %s: %s", fname, pcap_strerror(errno));

	if (fstat(fd, &buf) < 0)
		error("can't stat %s: %s", fname, pcap_strerror(errno));

	cp = malloc((u_int)buf.st_size + 1);
	if (cp == NULL)
		error("malloc(%d) for %s: %s", (u_int)buf.st_size + 1,
			fname, pcap_strerror(errno));
	cc = read(fd, cp, (u_int)buf.st_size);
	if (cc < 0)
		error("read %s: %s", fname, pcap_strerror(errno));
	if (cc != buf.st_size)
		error("short read %s (%d != %d)", fname, cc, (int)buf.st_size);

	close(fd);
	/* replace "# comment" with spaces */
	for (i = 0; i < cc; i++) {
		if (cp[i] == '#')
			while (i < cc && cp[i] != '\n')
				cp[i++] = ' ';
	}
	cp[cc] = '\0';
	return (cp);
}

#ifdef HAVE_PCAP_FINDALLDEVS
static long
parse_interface_number(const char *device)
{
	long devnum;
	char *end;

	devnum = strtol(device, &end, 10);
	if (device != end && *end == '\0') {
		/*
		 * It's all-numeric, but is it a valid number?
		 */
		if (devnum <= 0) {
			/*
			 * No, it's not an ordinal.
			 */
			error("Invalid adapter index");
		}
		return (devnum);
	} else {
		/*
		 * It's not all-numeric; return -1, so our caller
		 * knows that.
		 */
		return (-1);
	}
}

static char *
find_interface_by_number(long devnum)
{
	pcap_if_t *dev, *devlist;
	long i;
	char ebuf[PCAP_ERRBUF_SIZE];
	char *device;

	if (pcap_findalldevs(&devlist, ebuf) < 0)
		error("%s", ebuf);
	/*
	 * Look for the devnum-th entry in the list of devices (1-based).
	 */
	for (i = 0, dev = devlist; i < devnum-1 && dev != NULL;
	    i++, dev = dev->next)
		;
	if (dev == NULL)
		error("Invalid adapter index");
	device = strdup(dev->name);
	pcap_freealldevs(devlist);
	return (device);
}
#endif

static pcap_t *
open_interface(const char *device, netdissect_options *ndo, char *ebuf)
{
	pcap_t *pc;
#ifdef HAVE_PCAP_CREATE
	int status;
	char *cp;
#endif

#ifdef HAVE_PCAP_CREATE
	pc = pcap_create(device, ebuf);
	if (pc == NULL) {
		/*
		 * If this failed with "No such device", that means
		 * the interface doesn't exist; return NULL, so that
		 * the caller can see whether the device name is
		 * actually an interface index.
		 */
		if (strstr(ebuf, "No such device") != NULL)
			return (NULL);
		error("%s", ebuf);
	}
#ifdef HAVE_PCAP_SET_TSTAMP_TYPE
	if (Jflag)
		show_tstamp_types_and_exit(pc, device);
#endif
#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	status = pcap_set_tstamp_precision(pc, ndo->ndo_tstamp_precision);
	if (status != 0)
		error("%s: Can't set %ssecond time stamp precision: %s",
			device,
			tstamp_precision_to_string(ndo->ndo_tstamp_precision),
			pcap_statustostr(status));
#endif

#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE
	if (immediate_mode) {
		status = pcap_set_immediate_mode(pc, 1);
		if (status != 0)
			error("%s: Can't set immediate mode: %s",
			device,
			pcap_statustostr(status));
	}
#endif
	/*
	 * Is this an interface that supports monitor mode?
	 */
	if (pcap_can_set_rfmon(pc) == 1)
		supports_monitor_mode = 1;
	else
		supports_monitor_mode = 0;
	status = pcap_set_snaplen(pc, ndo->ndo_snaplen);
	if (status != 0)
		error("%s: Can't set snapshot length: %s",
		    device, pcap_statustostr(status));
	status = pcap_set_promisc(pc, !pflag);
	if (status != 0)
		error("%s: Can't set promiscuous mode: %s",
		    device, pcap_statustostr(status));
	if (Iflag) {
		status = pcap_set_rfmon(pc, 1);
		if (status != 0)
			error("%s: Can't set monitor mode: %s",
			    device, pcap_statustostr(status));
	}
	status = pcap_set_timeout(pc, 1000);
	if (status != 0)
		error("%s: pcap_set_timeout failed: %s",
		    device, pcap_statustostr(status));
	if (Bflag != 0) {
		status = pcap_set_buffer_size(pc, Bflag);
		if (status != 0)
			error("%s: Can't set buffer size: %s",
			    device, pcap_statustostr(status));
	}
	else
	/*{

		PFUNLINE;
		//fprintf(stdout,"Bflag=%d,bufsize=%d\n",Bflag,pcap_bufsize(pd));
	
		status = pcap_set_buffer_size(pc, 102400);
		if (status != 0)
			error("%s: Can't set buffer size: %s",
			    device, pcap_statustostr(status));
	}*/
	
///	PFUNLINE;
///	fprintf(stdout,"Bflag=%d,bufsize=%d\n",Bflag,pcap_bufsize(pc));

	
		
#ifdef HAVE_PCAP_SET_TSTAMP_TYPE
	if (jflag != -1) {
		status = pcap_set_tstamp_type(pc, jflag);
		if (status < 0)
			error("%s: Can't set time stamp type: %s",
		              device, pcap_statustostr(status));
		else if (status > 0)
			warning("When trying to set timestamp type '%s' on %s: %s",
				pcap_tstamp_type_val_to_name(jflag), device,
				pcap_statustostr(status));
	}
#endif
	status = pcap_activate(pc);
	if (status < 0) {
		/*
		 * pcap_activate() failed.
		 */
		cp = pcap_geterr(pc);
		if (status == PCAP_ERROR)
			error("%s", cp);
		else if (status == PCAP_ERROR_NO_SUCH_DEVICE) {
			/*
			 * Return an error for our caller to handle.
			 */
			snprintf(ebuf, PCAP_ERRBUF_SIZE, "%s: %s\n(%s)",
			    device, pcap_statustostr(status), cp);
			pcap_close(pc);
			return (NULL);
		} else if (status == PCAP_ERROR_PERM_DENIED && *cp != '\0')
			error("%s: %s\n(%s)", device,
			    pcap_statustostr(status), cp);
		else
			error("%s: %s", device,
			    pcap_statustostr(status));
	} else if (status > 0) {
		/*
		 * pcap_activate() succeeded, but it's warning us
		 * of a problem it had.
		 */
		cp = pcap_geterr(pc);
		if (status == PCAP_WARNING)
			warning("%s", cp);
		else if (status == PCAP_WARNING_PROMISC_NOTSUP &&
		         *cp != '\0')
			warning("%s: %s\n(%s)", device,
			    pcap_statustostr(status), cp);
		else
			warning("%s: %s", device,
			    pcap_statustostr(status));
	}
#ifdef HAVE_PCAP_SETDIRECTION
	if (Qflag != -1) {
		status = pcap_setdirection(pc, Qflag);
		if (status != 0)
			error("%s: pcap_setdirection() failed: %s",
			      device,  pcap_geterr(pc));
		}
#endif /* HAVE_PCAP_SETDIRECTION */
#else /* HAVE_PCAP_CREATE */
	*ebuf = '\0';
	pc = pcap_open_live(device, ndo->ndo_snaplen, !pflag, 1000, ebuf);
	if (pc == NULL) {
		/*
		 * If this failed with "No such device", that means
		 * the interface doesn't exist; return NULL, so that
		 * the caller can see whether the device name is
		 * actually an interface index.
		 */
		if (strstr(ebuf, "No such device") != NULL)
			return (NULL);
		error("%s", ebuf);
	}
	if (*ebuf)
		warning("%s", ebuf);
#endif /* HAVE_PCAP_CREATE */

	return (pc);
}

char dirName[100] = "../pcapfile";
#define  F_OK  0

void set_month(char *str,char a, char b){
	*(str+4) = a;
	*(str+5) = b;
}

int getallfilesize(char *objpath)
{
	FILE *fstream=NULL;
	char buff[1024]; 
	int allfvalue = 0;
	if(NULL == objpath)
	{
		//默认当前路径?
	}
	
	if(NULL==(fstream=popen("du -sh","r")))    
	{	
		fprintf(stderr,"execute command failed: ");    
		allfvalue = -1;	  
		goto FUNEND;
	}	

	if(NULL==fgets(buff, sizeof(buff), fstream)) 
	{
		fprintf(stderr,"execute command failed: ");    
		allfvalue = -1;	  
		goto FUNEND;
	}
	if(strchr(buff,'G') == NULL)
	{
		allfvalue = 0;
	}
	else
	{
		allfvalue = atoi(buff);
	}
FUNEND:	
	pclose(fstream);  	
	return allfvalue;
}

FILE *getshellvalue(char *pcmd)
{
	FILE * fstream = NULL;

	if(NULL==(fstream=popen(pcmd,"r")))    
	{   
	   fprintf(stdout,"execute command failed: ");	  
	   return NULL;	 
	} 

	return fstream;
}
void setworkpath(char *cmd,char *path)
{
	int len = 0;
	
	FILE * fposstream = NULL;	
	
	fposstream = getshellvalue(cmd);
	while (NULL != fgets(path, PATH_MAX, fposstream))
	{
		break;
	}	
	fclose(fposstream); 
	len = strlen(path);	
	path[len-1] = '\0';
	//PFUNLINE;
	//fprintf(stdout,"\nfile pos %s\n",path); 
	return;
}

void * removeoldfile()
{  
	int ms1,ms2,m3,m4;

	FILE *fsizestream = NULL;    
	FILE *fnamestream = NULL; 
	FILE *fcpustream = NULL;

	char sizebuff[128] = "\0";
	char namebuff[128] = "\0";
	char cpuused[16] = "\0";
	char path[PATH_MAX] = "\0";
	char *cmd;
	int i = 0;
	int rtn = 0;
	int dvalue = 0;
	int fvalue = 0;
	int nvalue = 0;
	char * pos = 0;
	int len = 0;
	char *pcmd = NULL;
	int idiff = 0;
	char scmd[128]="\0";
	int delsize=0;

	//fprintf(stdout,"%s,pid=%d\n",__FUNCTION__,getpid());
	system("sudo updatedb");

	cmd = "locate pcapfile -n 1";
	setworkpath(cmd,path);
	chdir(path); 
	//system("pwd");

	while(1)
	{
		if(run == 0)
		{
			fprintf(stdout,"return %s,pid=%d\n",__FUNCTION__,getpid());
			return;
		}
		
		sleep(2);
		delsize = 0;
		
		dvalue = getallfilesize(NULL);

		
		if(dvalue < MAX_DU_FILE)	//not to remove for this,only get size
		{
			continue;
		}
		
		//get file size and name for remove
		pcmd = "ls -trl | awk '{print $5}'";
		fsizestream = getshellvalue(pcmd);
		
		pcmd = "ls -trl | awk '{print $9}'";
		fnamestream = getshellvalue(pcmd);

		assert((fsizestream != NULL) && (fnamestream != NULL));

		
		while((NULL != fgets(sizebuff, sizeof(sizebuff), fsizestream)) && 
			(NULL != fgets(namebuff, sizeof(namebuff), fnamestream)))
		{

			if(run == 0)
			{
				fprintf(stdout,"return %s,pid=%d\n",__FUNCTION__,getpid());
				return;
			}
		
			ms1 = gettimeofdayms();
			fvalue = atoi(sizebuff);
			
			if(fvalue == 0)
			{
				//continue; 	//del 0K file
			}
			nvalue = atoi(namebuff);
			if(nvalue == 0)
			{
				continue;
			}

			delsize +=fvalue;	
				
			len = strlen(namebuff);	
			namebuff[len-1]='\0';
			
			rtn = remove(namebuff);
			
			fprintf(stdout,"\n\t remove:%s,-filesize=%dM,pid=%d\n",namebuff,fvalue/(1024*1024),getpid());		
			ms2 = gettimeofdayms();

			if(delsize > MAX_DEL_FILE)
				break;

			sleep(3);

			/*
			ms1 = gettimeofdayms();

			pcmd = "top -n 1 | grep \"infodump\" | awk '{print $10}'";
			fcpustream = getshellvalue(pcmd);

			if(NULL != fgets(cpuused, sizeof(cpuused), fcpustream))
			{
				fprintf(stdout,"\n\t now cpu = %s\n",cpuused);
			}
			else
			{
				fprintf(stdout,"\n\t now cpu = NULL\n");
			}

			ms2 = gettimeofdayms();
			fprintf(stdout,"\n\t top -n 1 use %d ms\n",ms2-ms1);*/
			
				
		}
	FUNEND:	
	
		pclose(fsizestream); 		
		pclose(fnamestream);
		//pclose(fcpustream);

	}
	
	return NULL;	
}


pcap_dumper_t* make_name()
{
	static int filenum = 1;
	int len = 0;
	char filenamenum[16] = "\0";
	char new_name[32]= "\0";
	pcap_dumper_t* p = NULL;

	char *token;
	int rtn = 0;
	/*
	if((rtn=access(dirName,F_OK))!=0)
	{
		rtn = system("mkdir ../pcapfile");
	}
		
	if (chmod("../pcapfile", S_IRWXU | S_IRWXG | S_IRWXO) < 0)
	{
		fprintf(stdout,"chmod file permission error\n");
	}
		
	rtn = chdir("../pcapfile");	*/
	
	long t = time(0);
	char *tp = ctime(&t);
	
	new_name[0]= '\0';
	strtok(tp, " "); //略过

	token = strtok(NULL, " ");	//获得几月
	if(!strcmp("Jan", token)){
		set_month(new_name,'0', '1');
	}else if(!strcmp("Feb", token)){
		set_month(new_name,'0', '2');
	}else if(!strcmp("Mar", token)){
		set_month(new_name,'0', '3');
	}else if(!strcmp("Apr", token)){
		set_month(new_name,'0', '4');
	}else if(!strcmp("May", token)){
		set_month(new_name,'0', '5');
	}else if(!strcmp("Jun", token)){
		set_month(new_name,'0', '6');
	}else if(!strcmp("Jul", token)){
		set_month(new_name,'0', '7');
	}else if(!strcmp("Aug", token)){
		set_month(new_name,'0', '8');
	}else if(!strcmp("Sep", token)){
		set_month(new_name,'0', '9');
	}else if(!strcmp("Oct", token)){
		set_month(new_name,'1', '0');
	}else if(!strcmp("Nov", token)){
		set_month(new_name,'1', '1');
	}else if(!strcmp("Dec", token)){
		set_month(new_name,'1', '2');
	}

	token = strtok(NULL, " "); //获得几号
	if(strlen(token) == 1){
		strncpy(new_name+6, "0", 1);
		strncpy(new_name+7, token, 1);
	}else{
		strncpy(new_name+6, token, 2);
	}
	token = strtok(NULL, " "); //获得几点
	strncpy(new_name+8, token, 2);
	
	//token = strtok(NULL, ":"); //获得?
	strncpy(new_name+10, token+3, 2);
	strncpy(new_name+12, token+6, 2); //second
	//debug("token: %s\n", token);

	token = strtok(NULL, " "); //获得?
	strncpy(new_name, token, 4);


	sprintf(filenamenum,"[%d].pcap",filenum);

	len = strlen(filenamenum);
	
	strncpy(new_name+14, filenamenum, len);
//#ifdef DUMP_DEBUG
	fprintf(stdout,"\n\t creat file:%s\n", new_name);
//#endif
	p=pcap_dump_open(pd,new_name);
	if (p == NULL)
		error("%s", pcap_geterr(pd));
	filenum++;

	len = strlen(new_name);
	strncpy(current_name,new_name,len);	
	flagforfilename = 1;
	return p;
}

#define RPSCHEDU SCHED_RR
#define WFSCHEDU SCHED_FIFO


//1，SCHED_OTHER 分时调度策略?
//2，SCHED_FIFO 实时调度策略，先到先服务
//3，SCHED_RR 实时调度策略，时间片轮转 

void setsystemscheduler( int         schduer)
{   
	 pid_t pid = getpid();
	 pid_t ppid = getppid();
	 //PFUNLINE;
	 //fprintf(stdout,"\n\t %s,%d,pid=%d,ppid=%d\n\n",__FUNCTION__,__LINE__,pid,ppid);
	 struct sched_param param;
	 //param.sched_priority = sched_get_priority_max(schduer);	// 	也可用SCHED_RR
	 //sched_setscheduler(pid, schduer, &param);					// 	设置当前进程
	 //pthread_setschedparam(pthread_self(), schduer, &param);	// 	设置当前线程
}

#if 0

void cap_log_wr(FILE *fp)
{
	//int o_flow = overflow;
	fseek(fp,0L,SEEK_SET);
	//fprintf(fp, "pcap buffer size is %um!\n", buff_size);
	//fprintf(fp, "Capture packets count is %u !\n", packet_count);
	fprintf(fp, "pcap_loop run!packet count is ");

	//while(o_flow--){
	//	fprintf(fp, "+");
	//}
	//fprintf(fp, "%u\n",packet_count);
	struct pcap_stat ps;
	memset(&ps,0,sizeof(ps));
	pcap_stats(pd,&ps);
	fprintf(fp, "ps.ps_recv = %u ,ps.ps_drop = %u ,ps.ps_ifdrop = %u  \n", ps.ps_recv,ps.ps_drop,ps.ps_ifdrop);
	long t;
	char *tp;
	t = time(0);
	tp = ctime(&t);
	fprintf(fp, "%s", tp);
	fflush(fp);
	fsync(fileno(fp));

}


void *write2file(void)
{
	unsigned int wflen = 0;
	unsigned int wpos=0,rpos=0;
	unsigned int rlen = 0;
	unsigned int slen=0,dlen=0;
	FILE * f = NULL;
		
	wpos = pstbuf->wpos;
	rpos = pstbuf->rpos;

	wflen =  (MAX_PACKET_LEN + wpos - rpos) % MAX_PACKET_LEN;

	if(0 == wflen)
	{
		///PFUNLINE;
		fprintf(stdout,"\n\t write2file come here for end wflen=%d\n",wflen);
		return;
	}

	pstbuf->w2ftime = pstbuf->captime;

	f = (FILE *)pstmyfile;

	if(pstbuf->wloop == pstbuf->rloop)
	{			
		rlen = wpos - rpos;
		fwrite(pstbuf->buffer + rpos,rlen,1,f);
		pstbuf->rpos += rlen;					
	}
	else
	{
		if((pstbuf->wloop - pstbuf->rloop) != 1)
		{
			PFUNLINE;
			fprintf(stdout,"\r error to write to file,wloop=%d,rloop=%d\n",pstbuf->wloop,pstbuf->rloop);
			return NULL;
		}
		slen = MAX_PACKET_LEN - rpos;
		fwrite(pstbuf->buffer + rpos,slen,1,f);
		pstbuf->rpos = 0;
		pstbuf->rloop ++;

		dlen = wflen - slen;
		fwrite(pstbuf->buffer + 0,dlen,1,f);
		pstbuf->rpos += dlen;
	}

	fflush(f);		
	fdatasync(fileno(f));
	//fclose(f);
	barrier();
///	PFUNLINE;
		
///	fprintf(stdout,"\r tcpdump and ipackets_captured=%d\n",packets_captured);
	
	return NULL;
}
#endif



void *write2file(void)
{
	//int ms1,ms2,ms3,ms4;
	unsigned int wflen = 0;
	unsigned int wpos=0,rpos=0;
	unsigned int rlen = 0;
	unsigned int slen=0,dlen=0;
	FILE * f = NULL;
	int flag =0;

	//ms1 = gettimeofdayms();

	pthread_mutex_lock(&mut1);
		
	wpos = pstbuf->wpos;
	rpos = pstbuf->rpos;

	wflen =  (pstbuf->endpos + wpos - rpos) % pstbuf->endpos;

	if(0 == wflen)
	{
		//fprintf(stdout,"\n\t write2file come here for end wflen=%d\n",wflen);
		pthread_mutex_unlock(&mut1);
		return NULL;
	}
	
	g_writedlen += wflen;

	judgeifbig();

	pstbuf->w2ftime = pstbuf->captime;

	f = (FILE *)pstmyfile;
	///fseek(f,0L,SEEK_END);

	//ms2 = gettimeofdayms();

	
	if(pstbuf->wloop == pstbuf->rloop)
	{			
		rlen = wpos - rpos;
		fwrite(pstbuf->buffer + rpos,rlen,1,f);
		pstbuf->rpos += rlen;					
	}
	else
	{		
		if(flag = (pstbuf->wloop - pstbuf->rloop) > 1)
		{
			//flag = pstbuf->wloop;
			pstbuf->wloop = pstbuf->rloop + 1;;
		}
		//写末尾部?
		slen = pstbuf->endpos - rpos;
		fwrite(pstbuf->buffer + rpos,slen,1,f);
		pstbuf->rpos = 0;
		pstbuf->rloop ++;

		//写开头部?
		dlen = pstbuf->wpos;
		fwrite(pstbuf->buffer + 0,dlen,1,f);
		pstbuf->rpos += dlen;
		flag = 1;
	}

ERROREND:
	pthread_mutex_unlock(&mut1);	

#ifdef DUMP_DEBUG	
	if(flag == 1)
	{
		fprintf(stdout,"\n\t reading buffer end stat,rloop=%d\n",pstbuf->rloop);
	}
	if(flag > 1)
	{
		fprintf(stdout,"\r error to write to file,wloop=%d,rloop=%d\n",flag,pstbuf->rloop);
		
	}
#endif
	//ms3 = gettimeofdayms();

	fflush(f);		

	//ms4 = gettimeofdayms();
	//fprintf(stdout,"\n\t ms2-ms1=%d,ms3-ms2=%d,ms4-ms3=%d,rlen=%d\n",ms2-ms1,ms3-ms2,ms4-ms3,rlen);

	return NULL;
}

void printnewcreatfile()
{

#ifdef DUMP_DEBUG
	if(flagforfilename > 0)
	{
		flagforfilename = 0;
		fprintf(stdout,"\n\t creat new file:%s\n",current_name);		
	}
#endif	
	return;
}
void *writefile_cb(void *arg)
{
	unsigned int wflen = 0;
	unsigned int wpos=0,rpos=0;
	unsigned int rlen = 0;
	unsigned int slen=0,dlen=0;
	unsigned int w2wtime;
	unsigned int cpunotoobusy = MIN_SAFE_LEN/100;

#ifdef DUMP_DEBUG	
	setsystemscheduler(WFSCHEDU);	
#endif

	fprintf(stdout,"\n\t start capturing...\n");

	while(run){
	
		wpos = pstbuf->wpos;
		rpos = pstbuf->rpos;

		w2wtime = (60 + pstbuf->captime - pstbuf->w2ftime) % 60;

		wflen =  (MAX_PACKET_LEN + wpos - rpos) % MAX_PACKET_LEN;
		// keep safe space for reduce write file num, and time less 5s
				
		if((wflen < MIN_SAFE_LEN) && (w2wtime < MAX_WAIE_SECOND))
		{		
			usleep(5);			
			continue;					
		}
		//fprintf(stdout,"\n\t wflen=%d,w2wtime=%d\n",wflen,w2wtime);

		write2file();	
	
		printnewcreatfile();
	
	}
	
	fprintf(stdout,"\n\tend capture and packets=%d\n",jupackets_captured);
	
	return NULL;
}



void sig_handler(int signo)
{    

	if(signo == SIGINT){//Ctrl + c			
			
		if(run)
			pcap_breakloop(pd);
		run = 0;	
		write2file();
	}
}

void init_savefilepath()
{
	int rtn =0;
	if((rtn=access(dirName,F_OK))!=0)
	{
		rtn = system("mkdir ../pcapfile");
	}
		
	if (chmod("../pcapfile", S_IRWXU | S_IRWXG | S_IRWXO) < 0)
	{
		fprintf(stdout,"chmod file permission error\n");
	}
		
	chdir("../pcapfile"); 
	return;
}

void free_mygloarg()
{
	free(pstbuf->buffer);
}
void init_mygloarg()
{
	pstbuf = &stbuf;

	pstbuf->rloop = 0;
	pstbuf->rpos = 0;
	pstbuf->wpos = 0;
	pstbuf->wloop = 0;
	pstbuf->captime = 0;
	pstbuf->w2ftime = 0;
	pstbuf->endpos = MAX_PACKET_LEN;
	
	pstbuf->buffer = (unsigned char *)malloc(MAX_PACKET_LEN+1);
	if(NULL == pstbuf->buffer)
		fprintf(stdout,"malloc error line=%d,fun=%s\n",__LINE__,__FUNCTION__);

}
void init_mutex_mut1()
{
	pthread_mutex_init(&mut1,NULL);
		
}

int
main(int argc, char **argv)
{
	pthread_t parse_th;
	pthread_t remove_th;
	int rtn;

	register int cnt, op, i;
	bpf_u_int32 localnet =0 , netmask = 0;
	int timezone_offset = 0;
	register char *cp, *infile, *cmdbuf, *device, *RFileName, *VFileName, *WFileName;
	pcap_handler callback;
	int dlt;
	const char *dlt_name;
	struct bpf_program fcode;
#ifndef _WIN32
	RETSIGTYPE (*oldhandler)(int);
#endif
	struct dump_info dumpinfo;
	u_char *pcap_userdata;
	char ebuf[PCAP_ERRBUF_SIZE];
	char VFileLine[PATH_MAX + 1];
	char *username = NULL;
	char *chroot_dir = NULL;
	char *ret = NULL;
	char *end;
#ifdef HAVE_PCAP_FINDALLDEVS
	pcap_if_t *devlist;
	long devnum;
#endif
	int status;
	FILE *VFile;
#ifdef HAVE_CAPSICUM
	cap_rights_t rights;
	int cansandbox;
#endif	/* HAVE_CAPSICUM */
	int Oflag = 1;			/* run filter code optimizer */
	int yflag_dlt = -1;
	const char *yflag_dlt_name = NULL;

	netdissect_options Ndo;
	netdissect_options *ndo = &Ndo;
#ifdef DUMP_DEBUG
	fprintf(stdout,"%s,argc=%d\n","welcome to mytcpdump~~~~~~~~~",argc);

	for(i=0;i<argc;i++)
	{
		  fprintf(stdout,"argv[%d]=%s\n",i,argv[i]);
	}
//	PFUNLINE;
#endif

	int removpid = fork();
	if(removpid == 0)
	{
		fprintf(stdout,"%s,line=%d,pid=%d\n",__FUNCTION__,__LINE__,getpid());
		removeoldfile();
		exit(0);
	}

	/*
	 * Initialize the netdissect code.
	 */
	if (nd_init(ebuf, sizeof ebuf) == -1)
		error("%s", ebuf);

	memset(ndo, 0, sizeof(*ndo));
	ndo_set_function_pointers(ndo);
	ndo->ndo_snaplen = DEFAULT_SNAPLEN;

	cnt = -1;
	device = NULL;
	infile = NULL;
	RFileName = NULL;
	VFileName = NULL;
	VFile = NULL;
	WFileName = NULL;
	dlt = -1;
	if ((cp = strrchr(argv[0], '/')) != NULL)
		ndo->program_name = program_name = cp + 1;
	else
		ndo->program_name = program_name = argv[0];

#ifdef _WIN32
	if (pcap_wsockinit() != 0)
		error("Attempting to initialize Winsock failed");
#endif /* _WIN32 */

	/*
	 * On platforms where the CPU doesn't support unaligned loads,
	 * force unaligned accesses to abort with SIGBUS, rather than
	 * being fixed up (slowly) by the OS kernel; on those platforms,
	 * misaligned accesses are bugs, and we want tcpdump to crash so
	 * that the bugs are reported.
	 */
	if (abort_on_misalignment(ebuf, sizeof(ebuf)) < 0)
		error("%s", ebuf);

	
#ifdef HAVE_PCAP_FINDALLDEVS
	if (Dflag)
		show_devices_and_exit();
#endif

	switch (ndo->ndo_tflag) {

	case 0: /* Default */
	case 4: /* Default + Date*/
		timezone_offset = gmt2local(0);
		break;

	case 1: /* No time stamp */
	case 2: /* Unix timeval style */
	case 3: /* Microseconds since previous packet */
        case 5: /* Microseconds since first packet */
		break;

	default: /* Not supported */
		error("only -t, -tt, -ttt, -tttt and -ttttt are supported");
		break;
	}

	if (ndo->ndo_fflag != 0 && (VFileName != NULL || RFileName != NULL))
		error("-f can not be used with -V or -r");

	if (VFileName != NULL && RFileName != NULL)
		error("-V and -r are mutually exclusive.");

#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE
	/*
	 * If we're printing dissected packets to the standard output
	 * rather than saving raw packets to a file, and the standard
	 * output is a terminal, use immediate mode, as the user's
	 * probably expecting to see packets pop up immediately.
	 */

	//if (WFileName == NULL && isatty(1))
	//	immediate_mode = 1;
#endif
	 {
		/*
		 * We're doing a live capture.
		 */

#ifdef CZL		
		device = "eth0";
#else
		device = "ens33";
#endif
			
		if (device == NULL) {
			/*
			 * No interface was specified.  Pick one.
			 */
#ifdef HAVE_PCAP_FINDALLDEVS
			/*
			 * Find the list of interfaces, and pick
			 * the first interface.
			 */
			if (pcap_findalldevs(&devlist, ebuf) >= 0 &&
			    devlist != NULL) {
				device = strdup(devlist->name);
				pcap_freealldevs(devlist);
			}
#else /* HAVE_PCAP_FINDALLDEVS */
			/*
			 * Use whatever interface pcap_lookupdev()
			 * chooses.
			 */
			device = pcap_lookupdev(ebuf);
#endif
			if (device == NULL)
				error("%s", ebuf);
		}


		/*
		 * Try to open the interface with the specified name.
		 */
		pd = open_interface(device, ndo, ebuf);


		if (pd == NULL) {
			/*
			 * That failed.  If we can get a list of
			 * interfaces, and the interface name
			 * is purely numeric, try to use it as
			 * a 1-based index in the list of
			 * interfaces.
			 */
#ifdef HAVE_PCAP_FINDALLDEVS
			devnum = parse_interface_number(device);
			if (devnum == -1) {
				/*
				 * It's not a number; just report
				 * the open error and fail.
				 */
				error("%s", ebuf);
			}

			/*
			 * OK, it's a number; try to find the
			 * interface with that index, and try
			 * to open it.
			 *
			 * find_interface_by_number() exits if it
			 * couldn't be found.
			 */
			device = find_interface_by_number(devnum);
			pd = open_interface(device, ndo, ebuf);
			if (pd == NULL)
				error("%s", ebuf);
#else /* HAVE_PCAP_FINDALLDEVS */
			/*
			 * We can't get a list of interfaces; just
			 * fail.
			 */
			error("%s", ebuf);
#endif /* HAVE_PCAP_FINDALLDEVS */
		}



		/*
		 * Let user own process after socket has been opened.
		 */
#ifndef _WIN32
		if (setgid(getgid()) != 0 || setuid(getuid()) != 0)
			fprintf(stderr, "Warning: setgid/setuid failed !\n");
#endif /* _WIN32 */

		if (Lflag)
			show_dlts_and_exit(pd, device);
		if (yflag_dlt >= 0) {
#ifdef HAVE_PCAP_SET_DATALINK
			if (pcap_set_datalink(pd, yflag_dlt) < 0)
				error("%s", pcap_geterr(pd));
#else
			/*
			 * We don't actually support changing the
			 * data link type, so we only let them
			 * set it to what it already is.
			 */
			if (yflag_dlt != pcap_datalink(pd)) {
				error("%s is not one of the DLTs supported by this device\n",
				      yflag_dlt_name);
			}
#endif
			(void)fprintf(stderr, "%s: data link type %s\n",
				      program_name, yflag_dlt_name);
			(void)fflush(stderr);
		}
		i = pcap_snapshot(pd);
		if (ndo->ndo_snaplen < i) {
			warning("snaplen raised from %d to %d", ndo->ndo_snaplen, i);
			ndo->ndo_snaplen = i;
		}
                if(ndo->ndo_fflag != 0) {
                        if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {
                                warning("foreign (-f) flag used but: %s", ebuf);
                        }
                }

	}
	if (infile)
		cmdbuf = read_infile(infile);
	else
		cmdbuf = copy_argv(&argv[optind]);

#ifdef HAVE_PCAP_SET_OPTIMIZER_DEBUG
	pcap_set_optimizer_debug(dflag);
#endif
	//liusx add 
	if(cmdbuf == NULL)
	{
		cmdbuf = MYFILERMODE;
	}
	if (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)
		error("%s", pcap_geterr(pd));

	fprintf(stdout,"cmdbuf=%s\n",cmdbuf);
	if (dflag) {
		bpf_dump(&fcode, dflag);
		pcap_close(pd);
		free(cmdbuf);
		pcap_freecode(&fcode);
		exit_tcpdump(0);
	}
	init_print(ndo, localnet, netmask, timezone_offset);

#ifndef _WIN32
	(void)setsignal(SIGPIPE, cleanup);
	(void)setsignal(SIGTERM, cleanup);
	(void)setsignal(SIGINT, cleanup); 
#endif /* _WIN32 */
#if defined(HAVE_FORK) || defined(HAVE_VFORK)
	(void)setsignal(SIGCHLD, child_cleanup);
#endif
	/* Cooperate with nohup(1) */
#ifndef _WIN32
	if ((oldhandler = setsignal(SIGHUP, cleanup)) != SIG_DFL)
		(void)setsignal(SIGHUP, oldhandler);
#endif /* _WIN32 */

#ifndef _WIN32
	/*
	 * If a user name was specified with "-Z", attempt to switch to
	 * that user's UID.  This would probably be used with sudo,
	 * to allow tcpdump to be run in a special restricted
	 * account (if you just want to allow users to open capture
	 * devices, and can't just give users that permission,
	 * you'd make tcpdump set-UID or set-GID).
	 *
	 * Tcpdump doesn't necessarily write only to one savefile;
	 * the general only way to allow a -Z instance to write to
	 * savefiles as the user under whose UID it's run, rather
	 * than as the user specified with -Z, would thus be to switch
	 * to the original user ID before opening a capture file and
	 * then switch back to the -Z user ID after opening the savefile.
	 * Switching to the -Z user ID only after opening the first
	 * savefile doesn't handle the general case.
	 */

	if (getuid() == 0 || geteuid() == 0) {
		if (username || chroot_dir)
			droproot(username, chroot_dir);
	}
#endif /* _WIN32 */
	

	if (pcap_setfilter(pd, &fcode) < 0)
		error("%s", pcap_geterr(pd));

	{
		dlt = pcap_datalink(pd);
		ndo->ndo_if_printer = get_if_printer(ndo, dlt);
		//callback = print_packet;
		callback = dump_packet;
//liusx mod
		//pcap_userdata = (u_char *)ndo;
		pcap_userdata = pstmyfile;
	}
	
		setsystemscheduler(RPSCHEDU);
		init_mygloarg();
		init_mutex_mut1();
		init_savefilepath();
		pstmyfile =  make_name();

		
#if 1
		if(pthread_create(&parse_th, NULL, writefile_cb, NULL) != 0){

			exit(1);
		}

	/*	if(pthread_create(&remove_th, NULL, removeoldfile, NULL) != 0){

			exit(1);
		}*/

		
		if(signal(SIGINT, sig_handler) == SIG_ERR){
			//debug("signal err!\n");
			exit(1);
		}	
#endif		

	//pthread_setconcurrency(10);
	//int ithread = pthread_getconcurrency();
	//printf("ithread=%d\n",ithread);
	//liusx add end 


#ifdef SIGNAL_REQ_INFO
	/*
	 * We can't get statistics when reading from a file rather
	 * than capturing from a device.
	 */
	if (RFileName == NULL)
		(void)setsignal(SIGNAL_REQ_INFO, requestinfo);
#endif

	if (ndo->ndo_vflag > 0 && WFileName) {
		/*
		 * When capturing to a file, "-v" means tcpdump should,
		 * every 10 seconds, "v"erbosely report the number of
		 * packets captured.
		 */
#ifdef USE_WIN32_MM_TIMER
		/* call verbose_stats_dump() each 1000 +/-100msec */
		timer_id = timeSetEvent(1000, 100, verbose_stats_dump, 0, TIME_PERIODIC);
		setvbuf(stderr, NULL, _IONBF, 0);
#elif defined(HAVE_ALARM)
		(void)setsignal(SIGALRM, verbose_stats_dump);
		alarm(1);
#endif
	}

	if (RFileName == NULL) {
		/*
		 * Live capture (if -V was specified, we set RFileName
		 * to a file from the -V file).  Print a message to
		 * the standard error on UN*X.
		 */
		if (!ndo->ndo_vflag && !WFileName) {
			(void)fprintf(stderr,
			    "%s: verbose output suppressed, use -v or -vv for full protocol decode\n",
			    program_name);
		} else
			(void)fprintf(stderr, "%s: ", program_name);
		dlt = pcap_datalink(pd);
		dlt_name = pcap_datalink_val_to_name(dlt);
		if (dlt_name == NULL) {
			(void)fprintf(stderr, "listening on %s, link-type %u, capture size %u bytes\n",
			    device, dlt, ndo->ndo_snaplen);
		} else {
			(void)fprintf(stderr, "listening on %s, link-type %s (%s), capture size %u bytes\n",
			    device, dlt_name,
			    pcap_datalink_val_to_description(dlt), ndo->ndo_snaplen);
		}
		(void)fflush(stderr);
	}

#ifdef HAVE_CAPSICUM
	cansandbox = (ndo->ndo_nflag && VFileName == NULL && zflag == NULL);
	if (cansandbox && cap_enter() < 0 && errno != ENOSYS)
		error("unable to enter the capability mode");
#endif	/* HAVE_CAPSICUM */

	do {
		status = pcap_loop(pd, cnt, callback, pcap_userdata);
		pthread_join(parse_th, NULL);
		write2file();
		
		if (WFileName == NULL) {
			/*
			 * We're printing packets.  Flush the printed output,
			 * so it doesn't get intermingled with error output.
			 */
			if (status == -2) {
				/*
				 * We got interrupted, so perhaps we didn't
				 * manage to finish a line we were printing.
				 * Print an extra newline, just in case.
				 */
				putchar('\n');
			}
			//(void)fflush(stdout);
		}
                if (status == -2) {
			/*
			 * We got interrupted. If we are reading multiple
			 * files (via -V) set these so that we stop.
			 */
			VFileName = NULL;
			ret = NULL;
		}
		if (status == -1) {
			/*
			 * Error.  Report it.
			 */
			(void)fprintf(stderr, "%s: pcap_loop: %s\n",
			    program_name, pcap_geterr(pd));
		}
		if (RFileName == NULL) {
			/*
			 * We're doing a live capture.  Report the capture
			 * statistics.
			 */
			info(1);
		}
		
		pcap_close(pd);
		if (VFileName != NULL) {
			ret = get_next_file(VFile, VFileLine);
			if (ret) {
				int new_dlt;

				RFileName = VFileLine;
				pd = pcap_open_offline(RFileName, ebuf);
				if (pd == NULL)
					error("%s", ebuf);
#ifdef HAVE_CAPSICUM
				cap_rights_init(&rights, CAP_READ);
				if (cap_rights_limit(fileno(pcap_file(pd)),
				    &rights) < 0 && errno != ENOSYS) {
					error("unable to limit pcap descriptor");
				}
#endif
				new_dlt = pcap_datalink(pd);
				if (new_dlt != dlt) {
					/*
					 * The new file has a different
					 * link-layer header type from the
					 * previous one.
					 */
					if (WFileName != NULL) {
						/*
						 * We're writing raw packets
						 * that match the filter to
						 * a pcap file.  pcap files
						 * don't support multiple
						 * different link-layer
						 * header types, so we fail
						 * here.
						 */
						error("%s: new dlt does not match original", RFileName);
					}

					/*
					 * We're printing the decoded packets;
					 * switch to the new DLT.
					 *
					 * To do that, we need to change
					 * the printer, change the DLT name,
					 * and recompile the filter with
					 * the new DLT.
					 */
					dlt = new_dlt;
					ndo->ndo_if_printer = get_if_printer(ndo, dlt);
					if (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)
						error("%s", pcap_geterr(pd));
				}

				/*
				 * Set the filter on the new file.
				 */
				if (pcap_setfilter(pd, &fcode) < 0)
					error("%s", pcap_geterr(pd));

				/*
				 * Report the new file.
				 */
				dlt_name = pcap_datalink_val_to_name(dlt);
				if (dlt_name == NULL) {
					fprintf(stderr, "reading from file %s, link-type %u\n",
					    RFileName, dlt);
				} else {
					fprintf(stderr,
					"reading from file %s, link-type %s (%s)\n",
					    RFileName, dlt_name,
					    pcap_datalink_val_to_description(dlt));
				}
			}
		}
	}
	while (ret != NULL);


	free_mygloarg();

	if(pstmyfile != NULL)
	{
		fclose((FILE *)pstmyfile);
	}
		
	pcap_freecode(&fcode);
	exit_tcpdump(status == -1 ? 1 : 0);
	
}

/* make a clean exit on interrupts */
static RETSIGTYPE
cleanup(int signo _U_)
{
#ifdef USE_WIN32_MM_TIMER
	if (timer_id)
		timeKillEvent(timer_id);
	timer_id = 0;
#elif defined(HAVE_ALARM)
	alarm(0);
#endif

#ifdef HAVE_PCAP_BREAKLOOP
	/*
	 * We have "pcap_breakloop()"; use it, so that we do as little
	 * as possible in the signal handler (it's probably not safe
	 * to do anything with standard I/O streams in a signal handler -
	 * the ANSI C standard doesn't say it is).
	 */
	pcap_breakloop(pd);
#else
	/*
	 * We don't have "pcap_breakloop()"; this isn't safe, but
	 * it's the best we can do.  Print the summary if we're
	 * not reading from a savefile - i.e., if we're doing a
	 * live capture - and exit.
	 */
	if (pd != NULL && pcap_file(pd) == NULL) {
		/*
		 * We got interrupted, so perhaps we didn't
		 * manage to finish a line we were printing.
		 * Print an extra newline, just in case.
		 */
		putchar('\n');
		(void)fflush(stdout);
		info(1);
	}
	exit_tcpdump(0);
#endif
}

/*
  On windows, we do not use a fork, so we do not care less about
  waiting a child processes to die
 */
#if defined(HAVE_FORK) || defined(HAVE_VFORK)
static RETSIGTYPE
child_cleanup(int signo _U_)
{
  wait(NULL);
}
#endif /* HAVE_FORK && HAVE_VFORK */


static void
info(register int verbose)
{
	struct pcap_stat stats;

	/*
	 * Older versions of libpcap didn't set ps_ifdrop on some
	 * platforms; initialize it to 0 to handle that.
	 */
	stats.ps_ifdrop = 0;
	if (pcap_stats(pd, &stats) < 0) {
		(void)fprintf(stderr, "pcap_stats: %s\n", pcap_geterr(pd));
		infoprint = 0;
		return;
	}

	if (!verbose)
		fprintf(stderr, "%s: ", program_name);

	(void)fprintf(stderr, "%u packet%s captured", packets_captured,
	    PLURAL_SUFFIX(packets_captured));
	if (!verbose)
		fputs(", ", stderr);
	else
		putc('\n', stderr);
	(void)fprintf(stderr, "%u packet%s received by filter", stats.ps_recv,
	    PLURAL_SUFFIX(stats.ps_recv));
	if (!verbose)
		fputs(", ", stderr);
	else
		putc('\n', stderr);
	(void)fprintf(stderr, "%u packet%s dropped by kernel", stats.ps_drop,
	    PLURAL_SUFFIX(stats.ps_drop));
	if (stats.ps_ifdrop != 0) {
		if (!verbose)
			fputs(", ", stderr);
		else
			putc('\n', stderr);
		(void)fprintf(stderr, "%u packet%s dropped by interface\n",
		    stats.ps_ifdrop, PLURAL_SUFFIX(stats.ps_ifdrop));
	} else
		putc('\n', stderr);
	infoprint = 0;
}

#if defined(HAVE_FORK) || defined(HAVE_VFORK)
#ifdef HAVE_FORK
#define fork_subprocess() fork()
#else
#define fork_subprocess() vfork()
#endif
static void
compress_savefile(const char *filename)
{
	pid_t child;

	child = fork_subprocess();
	if (child == -1) {
		fprintf(stderr,
			"compress_savefile: fork failed: %s\n",
			pcap_strerror(errno));
		return;
	}
	if (child != 0) {
		/* Parent process. */
		return;
	}

	/*
	 * Child process.
	 * Set to lowest priority so that this doesn't disturb the capture.
	 */
#ifdef NZERO
	setpriority(PRIO_PROCESS, 0, NZERO - 1);
#else
	setpriority(PRIO_PROCESS, 0, 19);
#endif
	if (execlp(zflag, zflag, filename, (char *)NULL) == -1)
		fprintf(stderr,
			"compress_savefile: execlp(%s, %s) failed: %s\n",
			zflag,
			filename,
			pcap_strerror(errno));
#ifdef HAVE_FORK
	exit(1);
#else
	_exit(1);
#endif
}
#else  /* HAVE_FORK && HAVE_VFORK */
static void
compress_savefile(const char *filename)
{
	fprintf(stderr,
		"compress_savefile failed. Functionality not implemented under your system\n");
}
#endif /* HAVE_FORK && HAVE_VFORK */

static void
dump_packet_and_trunc(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
{
	struct dump_info *dump_info;

	++packets_captured;

	++infodelay;

	dump_info = (struct dump_info *)user;

	/*
	 * XXX - this won't force the file to rotate on the specified time
	 * boundary, but it will rotate on the first packet received after the
	 * specified Gflag number of seconds. Note: if a Gflag time boundary
	 * and a Cflag size boundary coincide, the time rotation will occur
	 * first thereby cancelling the Cflag boundary (since the file should
	 * be 0).
	 */
	if (Gflag != 0) {
		/* Check if it is time to rotate */
		time_t t;

		/* Get the current time */
		if ((t = time(NULL)) == (time_t)-1) {
			error("dump_and_trunc_packet: can't get current_time: %s",
			    pcap_strerror(errno));
		}


		/* If the time is greater than the specified window, rotate */
		if (t - Gflag_time >= Gflag) {
#ifdef HAVE_CAPSICUM
			FILE *fp;
			int fd;
#endif

			/* Update the Gflag_time */
			Gflag_time = t;
			/* Update Gflag_count */
			Gflag_count++;
			/*
			 * Close the current file and open a new one.
			 */
			pcap_dump_close(dump_info->p);

			/*
			 * Compress the file we just closed, if the user asked for it
			 */
			if (zflag != NULL)
				compress_savefile(dump_info->CurrentFileName);

			/*
			 * Check to see if we've exceeded the Wflag (when
			 * not using Cflag).
			 */
			if (Cflag == 0 && Wflag > 0 && Gflag_count >= Wflag) {
				(void)fprintf(stderr, "Maximum file limit reached: %d\n",
				    Wflag);
				info(1);
				exit_tcpdump(0);
				/* NOTREACHED */
			}
			if (dump_info->CurrentFileName != NULL)
				free(dump_info->CurrentFileName);
			/* Allocate space for max filename + \0. */
			dump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);
			if (dump_info->CurrentFileName == NULL)
				error("dump_packet_and_trunc: malloc");
			/*
			 * Gflag was set otherwise we wouldn't be here. Reset the count
			 * so multiple files would end with 1,2,3 in the filename.
			 * The counting is handled with the -C flow after this.
			 */
			Cflag_count = 0;

			/*
			 * This is always the first file in the Cflag
			 * rotation: e.g. 0
			 * We also don't need numbering if Cflag is not set.
			 */
			if (Cflag != 0)
				MakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0,
				    WflagChars);
			else
				MakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0, 0);

#ifdef HAVE_LIBCAP_NG
			capng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);
			capng_apply(CAPNG_SELECT_BOTH);
#endif /* HAVE_LIBCAP_NG */
#ifdef HAVE_CAPSICUM
			fd = openat(dump_info->dirfd,
			    dump_info->CurrentFileName,
			    O_CREAT | O_WRONLY | O_TRUNC, 0644);
			if (fd < 0) {
				error("unable to open file %s",
				    dump_info->CurrentFileName);
			}
			fp = fdopen(fd, "w");
			if (fp == NULL) {
				error("unable to fdopen file %s",
				    dump_info->CurrentFileName);
			}
			dump_info->p = pcap_dump_fopen(dump_info->pd, fp);
#else	/* !HAVE_CAPSICUM */
			dump_info->p = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);
#endif
#ifdef HAVE_LIBCAP_NG
			capng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);
			capng_apply(CAPNG_SELECT_BOTH);
#endif /* HAVE_LIBCAP_NG */
			if (dump_info->p == NULL)
				error("%s", pcap_geterr(pd));
#ifdef HAVE_CAPSICUM
			set_dumper_capsicum_rights(dump_info->p);
#endif
		}
	}

	/*
	 * XXX - this won't prevent capture files from getting
	 * larger than Cflag - the last packet written to the
	 * file could put it over Cflag.
	 */
	if (Cflag != 0) {
		long size = pcap_dump_ftell(dump_info->p);

		if (size == -1)
			error("ftell fails on output file");
		if (size > Cflag) {
#ifdef HAVE_CAPSICUM
			FILE *fp;
			int fd;
#endif

			/*
			 * Close the current file and open a new one.
			 */
			pcap_dump_close(dump_info->p);

			/*
			 * Compress the file we just closed, if the user
			 * asked for it.
			 */
			if (zflag != NULL)
				compress_savefile(dump_info->CurrentFileName);

			Cflag_count++;
			if (Wflag > 0) {
				if (Cflag_count >= Wflag)
					Cflag_count = 0;
			}
			if (dump_info->CurrentFileName != NULL)
				free(dump_info->CurrentFileName);
			dump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);
			if (dump_info->CurrentFileName == NULL)
				error("dump_packet_and_trunc: malloc");
			MakeFilename(dump_info->CurrentFileName, dump_info->WFileName, Cflag_count, WflagChars);
#ifdef HAVE_LIBCAP_NG
			capng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);
			capng_apply(CAPNG_SELECT_BOTH);
#endif /* HAVE_LIBCAP_NG */
#ifdef HAVE_CAPSICUM
			fd = openat(dump_info->dirfd, dump_info->CurrentFileName,
			    O_CREAT | O_WRONLY | O_TRUNC, 0644);
			if (fd < 0) {
				error("unable to open file %s",
				    dump_info->CurrentFileName);
			}
			fp = fdopen(fd, "w");
			if (fp == NULL) {
				error("unable to fdopen file %s",
				    dump_info->CurrentFileName);
			}
			dump_info->p = pcap_dump_fopen(dump_info->pd, fp);
#else	/* !HAVE_CAPSICUM */
			dump_info->p = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);
#endif
#ifdef HAVE_LIBCAP_NG
			capng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);
			capng_apply(CAPNG_SELECT_BOTH);
#endif /* HAVE_LIBCAP_NG */
			if (dump_info->p == NULL)
				error("%s", pcap_geterr(pd));
#ifdef HAVE_CAPSICUM
			set_dumper_capsicum_rights(dump_info->p);
#endif
		}
	}

	pcap_dump((u_char *)dump_info->p, h, sp);
#ifdef HAVE_PCAP_DUMP_FLUSH
	if (Uflag)
		pcap_dump_flush(dump_info->p);
#endif

	--infodelay;
	if (infoprint)
		info(0);
}


//liusx add
void judgeifbig()
{
	
	//if(jupackets_captured > MAX_PACKETSNUM_IN_FILE)
	
	if(g_writedlen > MAX_DUMP_FILE_SIZE)
	{
		g_writedlen = 0;		
		fclose((FILE *)pstmyfile);
		pstmyfile =  make_name();			
	}
	return;
}



void getpackettime(stpcap_time *pstime, struct pcap_pkthdr *h)
{
	pstime->caplen = h->caplen;
	pstime->len = h->len;
	pstime->tv_sec = h->ts.tv_sec;
	pstime->tv_usec = h->ts.tv_usec;
	return;
}

//仅取int型部分即?
int gettimeofdayms()
{
	struct timeval tv;
	//struct timezone tz;
	long  ms = 0;
	gettimeofday (&tv, NULL);
	ms = tv.tv_sec * 1000 + tv.tv_usec/1000;
	return (int)ms;	
}
void mypcap_dump(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
{
	unsigned int wpos = 0;
	unsigned int looppos = 0;
	unsigned int slen = 0,dlen = 0;
	unsigned int tlen = sizeof(stpcap_time);
	stpcap_time sttime;
	unsigned char write2loop[2048]="\0";
	
	getpackettime(&sttime,h);

	wpos = pstbuf->wpos;
		
	pstbuf->captime = sttime.tv_sec;

	looppos = wpos + h->caplen + tlen;
	if(looppos > MAX_PACKET_LEN)  //已写到buffer的尾端，len?分两部分写入
	{
		//fprintf(stdout,"\n\t in the go back stat endpos=%d\n",wpos/(1024*1024));
		pstbuf->endpos = wpos;
		pstbuf->wloop++;
		pstbuf->wpos = 0;
		wpos = 0;	
		flagforprint ++;
	}	
	
	memcpy(pstbuf->buffer + wpos,&sttime,tlen);
	pstbuf->wpos += tlen;
	wpos = pstbuf->wpos;
	memcpy(pstbuf->buffer + wpos,sp,h->caplen);			
	pstbuf->wpos += h->caplen;
				
}
void getifgobackstat(void)
{
#ifdef DUMP_DEBUG
	if(flagforprint > 0)  //已写到buffer的尾端，len?分两部分写入
	{
		fprintf(stdout,"\n\t dump in the go back stat,wloop=%d,endpos=%d,looptimes=%d\n",pstbuf->wloop,pstbuf->endpos/(1024*1024),flagforprint);
		flagforprint = 0;
	}
#endif	
}

static void
dump_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
{
	
	++packets_captured;

	++infodelay;

//liusx add	
#if 0
	pcap_dump(user, h, sp);
#else
	++jupackets_captured;

	pthread_mutex_lock(&mut1);	
	mypcap_dump(user, h, sp);
	pthread_mutex_unlock(&mut1);
	getifgobackstat();
	
#endif
//liusx add end
	
#ifdef HAVE_PCAP_DUMP_FLUSH
	if (Uflag)
		pcap_dump_flush((pcap_dumper_t *)user);
#endif

	--infodelay;
	if (infoprint)
		info(0);
}

static void
print_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
{
	++packets_captured;

	++infodelay;

	pretty_print_packet((netdissect_options *)user, h, sp, packets_captured);
	//mypretty_print_packet((netdissect_options *)user, h, sp, packets_captured);

	--infodelay;
	if (infoprint)
		info(0);
}

#ifdef _WIN32
	/*
	 * XXX - there should really be libpcap calls to get the version
	 * number as a string (the string would be generated from #defines
	 * at run time, so that it's not generated from string constants
	 * in the library, as, on many UNIX systems, those constants would
	 * be statically linked into the application executable image, and
	 * would thus reflect the version of libpcap on the system on
	 * which the application was *linked*, not the system on which it's
	 * *running*.
	 *
	 * That routine should be documented, unlike the "version[]"
	 * string, so that UNIX vendors providing their own libpcaps
	 * don't omit it (as a couple of vendors have...).
	 *
	 * Packet.dll should perhaps also export a routine to return the
	 * version number of the Packet.dll code, to supply the
	 * "Wpcap_version" information on Windows.
	 */
	char WDversion[]="current-git.tcpdump.org";
#if !defined(HAVE_GENERATED_VERSION)
	char version[]="current-git.tcpdump.org";
#endif
	char pcap_version[]="current-git.tcpdump.org";
	char Wpcap_version[]="3.1";
#endif

#ifdef SIGNAL_REQ_INFO
RETSIGTYPE requestinfo(int signo _U_)
{
	if (infodelay)
		++infoprint;
	else
		info(0);
}
#endif

/*
 * Called once each second in verbose mode while dumping to file
 */
#ifdef USE_WIN32_MM_TIMER
void CALLBACK verbose_stats_dump (UINT timer_id _U_, UINT msg _U_, DWORD_PTR arg _U_,
				  DWORD_PTR dw1 _U_, DWORD_PTR dw2 _U_)
{
	if (infodelay == 0)
		fprintf(stderr, "Got %u\r", packets_captured);
}
#elif defined(HAVE_ALARM)
static void verbose_stats_dump(int sig _U_)
{
	if (infodelay == 0)
		fprintf(stderr, "Got %u\r", packets_captured);
	alarm(1);
}
#endif

USES_APPLE_DEPRECATED_API
static void
print_version(void)
{
	extern char version[];
#ifndef HAVE_PCAP_LIB_VERSION
#if defined(_WIN32) || defined(HAVE_PCAP_VERSION)
	extern char pcap_version[];
#else /* defined(_WIN32) || defined(HAVE_PCAP_VERSION) */
	static char pcap_version[] = "unknown";
#endif /* defined(_WIN32) || defined(HAVE_PCAP_VERSION) */
#endif /* HAVE_PCAP_LIB_VERSION */
	const char *smi_version_string;

#ifdef HAVE_PCAP_LIB_VERSION
#ifdef _WIN32
	(void)fprintf(stderr, "%s version %s, based on tcpdump version %s\n", program_name, WDversion, version);
#else /* _WIN32 */
	(void)fprintf(stderr, "%s version %s\n", program_name, version);
#endif /* _WIN32 */
	(void)fprintf(stderr, "%s\n",pcap_lib_version());
#else /* HAVE_PCAP_LIB_VERSION */
#ifdef _WIN32
	(void)fprintf(stderr, "%s version %s, based on tcpdump version %s\n", program_name, WDversion, version);
	(void)fprintf(stderr, "WinPcap version %s, based on libpcap version %s\n",Wpcap_version, pcap_version);
#else /* _WIN32 */
	(void)fprintf(stderr, "%s version %s\n", program_name, version);
	(void)fprintf(stderr, "libpcap version %s\n", pcap_version);
#endif /* _WIN32 */
#endif /* HAVE_PCAP_LIB_VERSION */

#if defined(HAVE_LIBCRYPTO) && defined(SSLEAY_VERSION)
	(void)fprintf (stderr, "%s\n", SSLeay_version(SSLEAY_VERSION));
#endif

	smi_version_string = nd_smi_version_string();
	if (smi_version_string != NULL)
		(void)fprintf (stderr, "SMI-library: %s\n", smi_version_string);

#if defined(__SANITIZE_ADDRESS__)
	(void)fprintf (stderr, "Compiled with AddressSanitizer/GCC.\n");
#elif defined(__has_feature)
#  if __has_feature(address_sanitizer)
	(void)fprintf (stderr, "Compiled with AddressSanitizer/CLang.\n");
#  endif
#endif /* __SANITIZE_ADDRESS__ or __has_feature */
}
USES_APPLE_RST

static void
print_usage(void)
{
	print_version();
	(void)fprintf(stderr,
"Usage: %s [-aAbd" D_FLAG "efhH" I_FLAG J_FLAG "KlLnNOpqStu" U_FLAG "vxX#]" B_FLAG_USAGE " [ -c count ]\n", program_name);
	(void)fprintf(stderr,
"\t\t[ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]\n");
	(void)fprintf(stderr,
"\t\t[ -i interface ]" j_FLAG_USAGE " [ -M secret ] [ --number ]\n");
#ifdef HAVE_PCAP_SETDIRECTION
	(void)fprintf(stderr,
"\t\t[ -Q in|out|inout ]\n");
#endif
	(void)fprintf(stderr,
"\t\t[ -r file ] [ -s snaplen ] ");
#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	(void)fprintf(stderr, "[ --time-stamp-precision precision ]\n");
	(void)fprintf(stderr,
"\t\t");
#endif
#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE
	(void)fprintf(stderr, "[ --immediate-mode ] ");
#endif
	(void)fprintf(stderr, "[ -T type ] [ --version ] [ -V file ]\n");
	(void)fprintf(stderr,
"\t\t[ -w file ] [ -W filecount ] [ -y datalinktype ] [ -z postrotate-command ]\n");
	(void)fprintf(stderr,
"\t\t[ -Z user ] [ expression ]\n");
}
/*
 * Local Variables:
 * c-style: whitesmith
 * c-basic-offset: 8
 * End:
 */
